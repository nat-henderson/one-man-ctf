\documentclass[12pt]{article}
\title{Single-Player Capture The Flag}
\author{Evan Gallo, Benjamin Kaplan, Jason Kuster, and Nathan McKinley}
\begin{document}
\maketitle
\tableofcontents
\section{Introduction}
Capture The Flag, in a security context, is a competition used to train people
to identify and exploit vulnerabilities in an appliction. In the original game,
two teams were pitted against each other. The flag was a file on a computer,
and the last one to "touch" the file was currently in control of it.

More recently, a single-player variant has arisen. This variation is more of a
test of personal ability rather than a group competition. In this variant, the
player is given access to an account on a computer. Their job is to find a
vulnerability that will let them get the password to the next account down the
line. They win when they complete all of the challenges set before them.

\section{Our Game}
This project is a single-player implementation, focusing on vulnerabilities
common to networked code. The game is run on 4 different machines.
Specifically, we have designed this to run in Amazon's Elastic Cloud Compute
(EC2) service.

The game consists of 8 challenges spread out over 4 machines. Rather than using
passwords, all of the accounts on the machines are set up using private key
authentication. At the beginning of the game, the user is given a file that
contains encrypted versions of all of the private keys. Each key is encrypted
with a 20-character random password. The goal of the game is to read the text
file in the home directory of the final user. There is a README file in every
user's home directory that gives hints on how to proceed. 

\section{The Levels}

\subsection{Level 1}
\paragraph{Vulnerability} Path Injection
\paragraph{Summary} The goal is to read the password.txt file in the level02
home directory. The user is given access to a small program, as well as the
C code for the utility. The program uses setuid() to set the user id to level02
and then uses the system function to call date.
\paragraph{Solution} Simply create your own executable program called "date"
that reads the password file. Put this file first on the path. Then, run the
printingdates program to get the password.

\subsection{Level 2}
\paragraph{Vulnerability} Poor Encryption
\paragraph{Summary}  The user is given access to a file named file.txt which appears to be gibberish.  It is encrypted using a simple letter-replacement cipher.  The location of the next machine is stored in the ciphertext.
\paragraph{Solution} Use a tool that analyzes the frequency of characters (such as a cryptogram solver) to decrypt the ciphertext.  The cleartext is the Declaration of Independence, with the hostname of the next server appended to the end.

\subsection{Level 3}

\subsection{Level 4}
\paragraph{Vulnerability} SMTP forging
\paragraph{Summary} Through a readme, the user is informed that there is this
server using this new ultra-secure email recovery system. All they need to do
is send an email from the user account on the local machine to
password-recovery and it will reply to their email with their password 
\paragraph{Solution} The trick here is that a reply is different than sending a
new message. Replies by convention use the Reply-To: header in the Data section
to determine the reciveing email address. 

The mail server is not running on the normal port, but an
nmap will tell you where it is Telnet to that server. In the MAIL FROM: field,
put "level04@computer-name". In the RCPT TO: field, put
"password-recovery@computer-name". In the Data section, set a Reply-To:
header to an email address you control. Send them message, wait a bit, and then
check your email. 
\subsection{Level 5}
\paragraph{Vulnerability} Packet Sniffing
\paragraph{Summary}  Through a readme, the user is informed that this machine
is an authentication server for another user who is bad with passwords.  This user
will send their password (known to be a bad password) to the server and the server
will respond with the password the user should use on other services (a presumably good
password).
\paragraph{Solution}  The user needs to capture an instance of this exchange and analyze it by hand.
They will do this using the packet capture utility installed on the machine, which we have altered
to allow for limited users to access hardware directly.  Upon doing this, the user will discover
the plaintext password "superdoublesecretpassword" sent to port 9125 on the current machine,
and an immediate reponse containing only the password for the next level, sent back over the same
connection.
\subsection{Level 6}
\paragraph{Vulnerability} Not-So-Poor Encryption
\paragraph{Summary} The user is given access to another file.txt which, again, appears to be gibberish.  This time, it is encrypted using single DES, which is known to be a weak encryption algorithm. The password to the next level is stored in the ciphertext. 
\paragraph{Solution} There are two possible solutions to this problem.  One would be to attack DES itself.  DES is a weak algorithm and can be broken, given enough time.  The other would be to perform a brute-force attack on the key.  This proves to be the easier attack, as the key is only four alphanumeric characters.

\subsection{Level 7}
\paragraph{Vulnerability} SQL Injection
\paragraph{Summary} The user is informed that there is a URL-shortening service installed on the current
machine.  It is an FCGI app in python which, depending on the querystring, will either shorten a URL
or redirect to a URL already shortened.  The app is backed by a mySQL database where the pairs are stored.
The strings that the user puts into the query string are not escaped; that's meant to be done by a frontend.
\paragraph{Solution} The user needs to figure out that the SQL statement being used is of the form 
"SELECT * FROM urls WHERE longurl='userstring'".  Since the app only acts on the first result returned, the
user needs to ensure that the SELECT call returns nothing, then make sure that the first response to the whole
statement they write is meaningful, or nothing will happen.  One possible solution is 
\begin{verbatim} 
' UNION SELECT * FROM passwords WHERE pw LIKE '\%
\end{verbatim}
This statement will select anything where the longurl parameter is empty (nothing) and take the union of that
result with every result from the table passwords.  The password will be stored in the "obfuscated URL" returned.
\subsection{Level 8}
\end{document}
